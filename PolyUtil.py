

# This file was *autogenerated* from the file PolyUtil.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
def get_coefficient(poly, exponent): # Returns the corresponding coefficient of poly
    R = LaurentPolynomialRing(ZZ, _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
    return (poly*t**(-exponent)).constant_coefficient()

def compute_triangle(P, p, num_rows): # Returns a num_rows x num_columns array and the column index of constant terms so that triangle[i][offset + j] = coeff_j(P^i)
    R = LaurentPolynomialRing(GF(p), _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)

    deg_right = P.degree()
    deg_left = (R(P)(t**-_sage_const_1 )).degree()
    num_columns = (num_rows - _sage_const_1 )*(deg_left + deg_right) + _sage_const_1 
    offset = (num_rows - _sage_const_1 )*deg_left # index of constant term
    triangle = []
    poly = _sage_const_1 
    for i in range(num_rows):
        row = [_sage_const_0  for j in range(num_columns)]
        for j in range(-i*deg_left, i*deg_right + _sage_const_1 ):
            row[j + offset] = get_coefficient(poly, j)
        triangle.append(row)
        poly = poly*P
    
    return (triangle, offset)

def Lambda(P, p): # If Q(t) is P(t) with all terms whose exponents are not multiples of p deleted, this returns Q(t^{1/p})
    R = LaurentPolynomialRing(GF(p), _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
    exps = R(P).exponents()
    d = R(P).dict()
    simp = R(_sage_const_0 ) # Begin with 0
    for j in range(len(d)):
        exp = exps[j]
        if (exp[_sage_const_0 ] % p == _sage_const_0 ): # Only include terms whose exponent is a multiple of p
            simp += d[exp]*t**(exp[_sage_const_0 ]/p) # Divide exponent by p
    return simp

