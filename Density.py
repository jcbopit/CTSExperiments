

# This file was *autogenerated* from the file Density.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_10000 = Integer(10000); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4)
def compute_densities(P, Q, p): # Computes the density of each output of ct[P^nQ] mod p
    # Begin by computing time spent on each DFA state, and then sum over states with equal outputs
    # For a reference, see Section 8.2 of Automatic Sequences by Allouche and Shallit
    from DFA import PolyAuto
    R = LaurentPolynomialRing(GF(p), _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
    (states, transitions, output_func) = PolyAuto(P, Q, p, _sage_const_10000 )

    mat = [[_sage_const_0  for _ in range(len(states))] for _ in range(len(states))]

    for i in range(len(states)):
        for j in range(p):
            (_, next_state_index) = transitions[i][j]
            mat[i][next_state_index] += _sage_const_1 

    count_mat = Matrix(mat)

    state_values = list(map(output_func, states))

    state_to_value = [[_sage_const_0  for _ in range(p)] for _ in range(len(states))]
    for i in range(len(states)):
        for j in range(p):
            if (state_values[i] == j):
                state_to_value[i][j] = _sage_const_1 

    def kill(x):
        if(x == p):
            return _sage_const_1 
        else:
            return _sage_const_0 
        
    def re(z):
        return z.real()

    (J, P) = Matrix(QQbar, count_mat).jordan_form(transformation=True)

    if (not P.is_invertible()): # For some reason this check is necessary to avoid errors sometimes
        raise Exception(f"Non-invertible matrix unexpected: {P}")

    state_densities = (Matrix([[_sage_const_1 ] + [_sage_const_0 ]*(len(states)-_sage_const_1 )])*P*J.apply_map(kill)*P.inverse()).apply_map(re)
    return state_densities*Matrix(state_to_value)

def motzkin_zero_density_mod(p): # Returns motzkin zero density according to Corollary 12
    from Sequences import Central_Trinomial, Motzkin_mod

    if(p == _sage_const_2 ): # 3-case form only holds for p>2
        return _sage_const_1 /_sage_const_3 
    for i in range(p):
        if(Central_Trinomial(i) % p == _sage_const_0 ):
            return _sage_const_1 
    
    F = GF(p)
    sgn = F(-_sage_const_3 )**((p-_sage_const_1 )/_sage_const_2 )
    motzkin_zero_count = _sage_const_0 
    likely_zero_count = _sage_const_0 
    unlikely_zero_count = _sage_const_0 

    for i in range(p-_sage_const_1 ):
        if (F(Central_Trinomial(i)) == sgn*F(Central_Trinomial(i+_sage_const_1 ))):
            likely_zero_count += _sage_const_1 
        if (F(Central_Trinomial(i)) == F(Central_Trinomial(i+_sage_const_1 ))):
            unlikely_zero_count += _sage_const_1 

    for i in range(p-_sage_const_2 ):
        if (Motzkin_mod(i, p)== _sage_const_0 ):
            motzkin_zero_count += _sage_const_1 
    
    density = motzkin_zero_count/p + _sage_const_2 *likely_zero_count/((p-_sage_const_1 )*(p+_sage_const_1 )) + _sage_const_2 *unlikely_zero_count/((p-_sage_const_1 )*p*(p+_sage_const_1 ))
    
    return density

def general_motzkin_zero_density_mod(a, b, p): # Returns motzkin zero density according to Proposition 11
    from Sequences import General_Central_Trinomial, General_Motzkin_mod

    if (p == _sage_const_2 ): # 3-case form only holds for p>2
        R = LaurentPolynomialRing(GF(p), _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
        return compute_densities(a*t**-_sage_const_1  + b + a*t, _sage_const_1 -t**_sage_const_2 , p)[_sage_const_0 ][_sage_const_0 ]
    
    if (a % p == _sage_const_0 ): # If p | a, then M^{a,b}_n = b^n mod p
        if (b % p == _sage_const_0 ):
            return _sage_const_1 
        else:
            return _sage_const_0 

    for i in range(p):
        if(General_Central_Trinomial(a, b, i) % p == _sage_const_0 ):
            return _sage_const_1 
    
    F = GF(p)
    sgn = F(b**_sage_const_2  - _sage_const_4 *a**_sage_const_2 )**((p-_sage_const_1 )/_sage_const_2 )
    motzkin_zero_count = _sage_const_0 
    likely_zero_count = _sage_const_0 
    unlikely_zero_count = _sage_const_0 

    for i in range(p-_sage_const_1 ):
        if (F(b)*F(General_Central_Trinomial(a, b, i)) == sgn*F(General_Central_Trinomial(a, b, i+_sage_const_1 ))):
            likely_zero_count += _sage_const_1 
        if (F(b)*F(General_Central_Trinomial(a, b, i)) == F(General_Central_Trinomial(a, b, i+_sage_const_1 ))):
            unlikely_zero_count += _sage_const_1 

    for i in range(p-_sage_const_2 ):
        if (General_Motzkin_mod(a, b, i, p) == _sage_const_0 ):
            motzkin_zero_count += _sage_const_1 
    
    density = motzkin_zero_count/p + _sage_const_2 *likely_zero_count/((p-_sage_const_1 )*(p+_sage_const_1 )) + _sage_const_2 *unlikely_zero_count/((p-_sage_const_1 )*p*(p+_sage_const_1 ))
    
    return density

def generic_linear_zero_density_mod(Q, a, b, c, d, p): # Returns motzkin zero density according to the process of Section 3.1
    from Sequences import Central_Trinomial, Constant_Term_mod

    F = GF(p)
    R = LaurentPolynomialRing(F, _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)

    if(p == _sage_const_2 ): # 3-case form only holds for p>2
        return compute_densities(t**-_sage_const_1  + _sage_const_1  + t, Q, p)[_sage_const_0 ][_sage_const_0 ]
    for i in range(p):
        if(Central_Trinomial(i) % p == _sage_const_0 ):
            return _sage_const_1 

    sgn = F(-_sage_const_3 )**((p-_sage_const_1 )/_sage_const_2 )
    zero_count = _sage_const_0 
    likely_zero_count = _sage_const_0 
    unlikely_zero_count = _sage_const_0 
    zs = []
    ls = []
    us = []

    for i in range(p-_sage_const_1 ):
        if (Constant_Term_mod(t**-_sage_const_1  + _sage_const_1  + t, Q, i, p) == _sage_const_0 ):
            zs.append(i)
            zero_count += _sage_const_1 
        if (a*F(Central_Trinomial(i)) == b*sgn*F(Central_Trinomial(i+_sage_const_1 ))):
            ls.append(i)
            likely_zero_count += _sage_const_1 
        if (c*F(Central_Trinomial(i)) == d*F(Central_Trinomial(i+_sage_const_1 ))):
            us.append(i)
            unlikely_zero_count += _sage_const_1 
    
    density = zero_count/p + likely_zero_count/((p-_sage_const_1 )*(p+_sage_const_1 )) + unlikely_zero_count/((p-_sage_const_1 )*p*(p+_sage_const_1 ))
    return density

