

# This file was *autogenerated* from the file Sequences.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4)
from functools import reduce

def Constant_Term(P, Q, n): # Naively computes ct[P^nQ]
    return ((P**n)*Q).constant_coefficient()

def Constant_Term_mod(P, Q, n, p): # Naively computes ct[P^nQ] mod p
    R = LaurentPolynomialRing(IntegerModRing(p), _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
    return ((R(P)**n)*R(Q)).constant_coefficient()

motzkin_array = [_sage_const_1 ,_sage_const_1 ] # Cached Motzkin sequence
def Motzkin(n): # A001006
    current_len = len(motzkin_array)
    if (n >= current_len): # Extend the cache if needed
        for i in range(n - current_len + _sage_const_1 ):
            # Compute next value using (n+2)M_n = (2n+1)M_{n-1} + 3(n-1)M_{n-2}
            motzkin_array.append(((_sage_const_2 *(i+current_len) + _sage_const_1 )*motzkin_array[len(motzkin_array) - _sage_const_1 ] + (_sage_const_3 *(i+current_len) - _sage_const_3 )*motzkin_array[len(motzkin_array) - _sage_const_2 ])/(i+_sage_const_2 +current_len))  
    
    return motzkin_array[n]

central_array = [_sage_const_1 ,_sage_const_1 ] # Cached Central Trinomial Sequence
def Central_Trinomial(n): # A002426
    current_len = len(central_array)
    if (n >= current_len): # Extend the cache if needed
        for i in range(n - current_len + _sage_const_1 ):
            # Compute next value using nT_n = (2n-1)T_{n-1} + 3(n-1)T_{n-2}
            central_array.append(((_sage_const_2 *(i+current_len) - _sage_const_1 )*central_array[len(central_array) - _sage_const_1 ] + (_sage_const_3 *(i+current_len) - _sage_const_3 )*central_array[len(central_array) - _sage_const_2 ])/(i+current_len))  
    
    return central_array[n]

def General_Central_Trinomial(a, b, n):
    if (n == _sage_const_0 ):
        return _sage_const_1 

    prev = _sage_const_1 
    next = b
    for i in range(_sage_const_2 , n+_sage_const_1 ):
        # Compute next value using nT_n = b(2n-1)T_{n-1} - (b^2 - 4a^2)(n-1)T_{n-2}
        new_next = (b*(_sage_const_2 *i - _sage_const_1 )*next - (b**_sage_const_2  - _sage_const_4 *a**_sage_const_2 )*(i - _sage_const_1 )*prev)/i
        prev = next
        next = new_next
    
    return next

def General_Motzkin(a, b, n):
    if (n == _sage_const_0 ):
        return _sage_const_1 

    prev = _sage_const_1 
    next = b
    for i in range(_sage_const_2 , n+_sage_const_1 ):
        # Compute next value using (n+2)M_n = b(2n+1)M_{n-1} - (b^2 - 4a^2)(n-1)M_{n-2}
        new_next = (b*(_sage_const_2 *i + _sage_const_1 )*next - (b**_sage_const_2  - _sage_const_4 *a**_sage_const_2 )*(i - _sage_const_1 )*prev)/(i+_sage_const_2 )
        prev = next
        next = new_next
    
    return next

def Central_Trinomial_mod(n, p): # Fast computation for A002426(n) mod p using the Lucas Congruence
    if (n == _sage_const_0 ):
        return _sage_const_1 
    
    R = IntegerModRing(p)

    def central_h(i): # Returns A002426 mod p computed without tricks (used for i < p)
        return R(Central_Trinomial(i))
    def mult_p(a, b): # Returns a*b mod p
        return R(a)*R(b)
    
    return reduce(mult_p, list(map(central_h, Integer(n).digits(p)))) # T_n is congruent to the product of T_{n_i} where n_i are the digits of n in base p

def General_Central_Trinomial_mod(a, b, n, p): # Fast computation for T^{a,b}(n) mod p using the Lucas Congruence
    if (n == _sage_const_0 ):
        return _sage_const_1 
    
    R = IntegerModRing(p)

    def central_h(i): # Returns A002426 mod p computed without tricks (used for i < p)
        return R(General_Central_Trinomial(a, b, i))
    def mult_p(a, b): # Returns a*b mod p
        return R(a)*R(b)
    
    return reduce(mult_p, list(map(central_h, Integer(n).digits(p)))) # T_n is congruent to the product of T_{n_i} where n_i are the digits of n in base p

def Motzkin_mod(n, p): # Fast computation for A001006(n) mod p using fast computation for A002426
    R = IntegerModRing(p)
    return (R(_sage_const_2 )**(-_sage_const_1 ))*(_sage_const_3 *Central_Trinomial_mod(n, p) + _sage_const_2 *Central_Trinomial_mod(n+_sage_const_1 , p) - Central_Trinomial_mod(n+_sage_const_2 , p)) # 2M_n = 3T_n + 2T_{n+1} - T_{n+2}

def General_Motzkin_mod(a, b, n, p): # Fast computation for M^{a,b} mod p using fast computation for T^{a,b}
    R = IntegerModRing(p)
    if (R(a) == _sage_const_0 ):
        return R(b)**n
    return (R(_sage_const_2 *a**_sage_const_2 )**(-_sage_const_1 ))*((_sage_const_4 *a**_sage_const_2  - b**_sage_const_2 )*General_Central_Trinomial_mod(a, b, n, p) + _sage_const_2 *b*General_Central_Trinomial_mod(a, b, n+_sage_const_1 , p) - General_Central_Trinomial_mod(a, b, n+_sage_const_2 , p)) # 2a^2M_n = (4a^2 - b^2)T_n + 2bT_{n+1} - T_{n+2}

def next_Motzkin_mod(prev, prev_n, p): # Even faster computation for A001006(prev_n + 1) mod p if A001006(prev_n) mod p is known
    prev_n0 = prev_n % p
    # If the least significant digit is < p-4, then we can undo the effect of this digit in M_{prev_n} computed using the Motzkin DFA and apply the effect of the successor digit
    if (prev_n0 < p-_sage_const_4 ):
        R = IntegerModRing(p)
        diff_mult = R(Motzkin_mod(prev_n0 + _sage_const_1 , p))*R(Motzkin_mod(prev_n0, p))**(-_sage_const_1 )
        return prev*diff_mult
    else: # Otherwise, just default to computing directly
        return Motzkin_mod(prev_n + _sage_const_1 , p)

def Motzkin_range_mod(index, size, p): # Returns [M_index mod p, ..., M_{index+size-1} mod p]
    prev = Motzkin_mod(index, p)
    result = [prev]
    for i in range(size-_sage_const_1 ):
        prev = next_Motzkin_mod(prev, index + i, p)
        result.append(prev)
    
    return result

def Motzkin_mod_p_mat(n, p): # Computes A001006(n) mod p using the regular representation
    R = LaurentPolynomialRing(ZZ, _sage_const_1 , names=('t',)); (t,) = R._first_ngens(1)
    f = t + _sage_const_1  + t**(-_sage_const_1 )

    def get_mat(k): # Computes the matrix-valued morphism in the regular representation of M_n mod p
        corner = _sage_const_0 
        if k == p-_sage_const_1 :
            corner = _sage_const_1 
        poly = f**k
        center = poly.constant_coefficient() % p
        side = _sage_const_0 
        if k > _sage_const_0 :
            side = poly.coefficients()[k+_sage_const_1 ] % p
        return Matrix([[corner, _sage_const_0 , _sage_const_0 ], [side, center, side], [_sage_const_0 , _sage_const_0 , corner]])

    def get_seed(k): # Computes the column vector in the regular representation of M_n mod p
        r = k % p

        mr = _sage_const_1 
        if (r > _sage_const_1 ):
            poly = f**r
            mr = (poly.coefficients()[r] - poly.coefficients()[r+_sage_const_2 ]) % p

        if r < p-_sage_const_2 :
            return Matrix([[_sage_const_0 ], [mr], [_sage_const_0 ]])
        elif r == p-_sage_const_2 :
            return Matrix([[_sage_const_0 ], [mr], [-_sage_const_1 ]])
        else:
            return Matrix([[_sage_const_0 ], [mr], [_sage_const_1 ]])
    
    # Compute using the regular representation of M_n mod p
    state = get_seed(n)
    for digit in Integer(n//p).digits(p):
        state = get_mat(digit)*state
    return state[_sage_const_1 ][_sage_const_0 ] # Equivalent to multiplying by the row vector [1, 0, ..., 0]

